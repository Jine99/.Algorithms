# [C++] 백준 18870번 좌표 압축

<p align="center">
<img width="840" alt="image" src="https://github.com/user-attachments/assets/9e3507ba-ef57-4936-a141-afd834d9d431" />
</p>

---

좌표 압축 문제이다. 입력받은 좌표값들을 작은 범위의 정수값으로 압축하여 출력하는 문제다.

문제를 처음 읽고 이해하는 데 시간이 오래 걸렸다. 이해하기 조금 어렵고 생소한 문제였다.

---
```cpp
    for (int i = 0; i < a; i++) {
        for (auto s : S) {
            if (arr[i] == s) {
                cout << b << " ";
            }
            b++;
        }
        b = 0;
    }
```
첫 구현은 배열과 set 자료구조를 사용해서 문제를 풀어보려고 했다.

set은 자동으로 정렬을 진행한다는 점과 중복 원소를 저장하지 않는다는 점을 이용해서

배열과 set으로 동시에 입력을 받고 set을 순회하면서 배열의 값과 같을 때 출력하는 값을 더하는 식으로 구현했다.

하지만 이렇게 구현하니 입력값이 많아지면 시간 초과로 문제를 해결할 수 없었고, 다른 방법을 생각했다.

---

이전에 배웠던 unique 함수와 erase 함수를 이용해서 다시 정렬하는 방법으로 문제를 풀어보았다.

```cpp
    sort(v2.begin(), v2.end());
    v2.erase(unique(v2.begin(), v2.end()), v2.end());
```
정렬은 이전에 배운 방법으로 쉽게 할 수 있었지만, 정렬만으로는 문제가 해결되지 않았다.

find 함수를 사용해서 값을 찾으려고 하다 보니 선형적으로 탐색하기 때문에 또다시 시간 초과 문제가 발생했다.

---

> ## lower_bound 함수
lower_bound 함수는 정렬된 원소에서 이진 탐색을 적용하여 특정 값 이상의 값이 처음 나타나는 위치를 반환하는 함수이다.

이를 통해 특정 값이 몇 번째인지 알아낼 수 있었고, 이진 탐색을 사용하기 때문에 속도도 매우 빠르다는 것을 알게 되었다.

```cpp
    for (int i = 0; i < a; i++) {
        cout << lower_bound(v2.begin(), v2.end(), v1[i]) - v2.begin() << " ";
    }
```
시작 위치인 begin부터 end까지에서 값의 위치를 찾아내고,

시작 위치인 begin을 빼주면 찾고자 하는 값의 위치를 알 수 있었고, 문제를 해결할 수 있었다.
